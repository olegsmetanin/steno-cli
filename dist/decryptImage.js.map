{"version":3,"sources":["../src/decryptImage.ts","../src/defaults.ts","../src/png.ts","../src/utils.ts"],"sourcesContent":["// Import downloaded module\nimport { PNG } from 'pngjs';\n\n// Import constants\nimport { BYTE_SIZE, LENGTH_BYTES, SHASUM_BYTES } from './defaults';\n// Import custom functions\nimport { isRgbByte } from './png';\nimport { decryptBuffer, getShasumData } from './utils';\n\nconst extractBinary = (b: number) => b % 2;\n\nconst splitBitsAsBytes = (bitsAsBytes: Buffer) => (_: number, i: number) => {\n  const start = i * BYTE_SIZE;\n  return bitsAsBytes.slice(start, start + BYTE_SIZE);\n};\n\nconst combineByteIntoBit = (accumulator: number, currentByte: number, i: number) => {\n  const shiftDistance = BYTE_SIZE - 1 - i;\n  /* tslint:disable:no-bitwise */\n  return (currentByte << shiftDistance) | accumulator;\n  /* tslint:enable:no-bitwise */\n};\n\nconst combineBufferIntoByte = (buffer: Buffer) => buffer.reduce(combineByteIntoBit, 0);\n\nconst combineBits = (bitsAsBytes: Buffer) => {\n  const n = Math.ceil(bitsAsBytes.length / BYTE_SIZE);\n  return Array(n).fill(null).map(splitBitsAsBytes(bitsAsBytes)).map(combineBufferIntoByte);\n};\n\nconst decode = (data: Buffer): Buffer => {\n  const bitsAsBytes = data.map(extractBinary) as Buffer;\n  const combined = combineBits(bitsAsBytes);\n  return Buffer.from(combined);\n};\n\nconst messageMatchesShasum = (message: Buffer, shasum: Buffer): boolean => getShasumData(message).equals(shasum);\n\nconst extractData = (imageData: Buffer) => {\n  const rgb: Uint8Array = imageData.filter(isRgbByte);\n\n  const lengthDataSize = LENGTH_BYTES * BYTE_SIZE;\n  const shasumDataSize = SHASUM_BYTES * BYTE_SIZE;\n  const lengthAndShasumSize = lengthDataSize + shasumDataSize;\n\n  const lengthData = rgb.slice(0, lengthDataSize) as Buffer;\n  const decodedLengthData = decode(lengthData);\n  const length = parseInt(decodedLengthData.toString('hex'), 16) * BYTE_SIZE;\n\n  const shasumData = rgb.slice(lengthDataSize, lengthAndShasumSize) as Buffer;\n  const decodedShasumData = decode(shasumData);\n\n  const messageData = rgb.slice(lengthAndShasumSize, lengthAndShasumSize + length) as Buffer;\n  const decodedMessageData = decode(messageData);\n\n  if (!messageMatchesShasum(decodedMessageData, decodedShasumData))\n    throw new Error('Shasum did not match decoded message');\n\n  return decodedMessageData;\n};\n\nexport const decryptImage = (image: Buffer, encoding?: BufferEncoding, password?: string) => {\n  const png: PNG = PNG.sync.read(image);\n  const data = extractData(png.data);\n  const output = password ? decryptBuffer(data, password) : data;\n  return encoding ? output.toString(encoding) : output;\n};\n","export const BYTE_SIZE = 8;\nexport const ENCRYPTION_METHOD = 'aes256';\nexport const LENGTH_BYTES = 8;\nexport const SHASUM_BYTES = 32;\n","// const { BYTE_SIZE } = require('./defaults')\nimport { BYTE_SIZE } from './defaults';\n\nconst CHANNEL_COUNT = ['r', 'g', 'b', 'a'].length;\n\nexport const countBytesForNRgbBytes = (n: number) => Math.floor((n * BYTE_SIZE * CHANNEL_COUNT) / (CHANNEL_COUNT - 1));\n\nexport const isAlphaByte = (_: number, i: number) => !((i + 1) % CHANNEL_COUNT);\nexport const isRgbByte = (_: number, i: number) => (i + 1) % CHANNEL_COUNT;\n\nexport const recombineRgbAndAlpha = (rgb: Buffer, alpha: Uint8Array) =>\n  Buffer.from(\n    Array(rgb.length + alpha.length)\n      .fill(null)\n      .map((_, i) => ((i + 1) % CHANNEL_COUNT ? rgb[i - Math.floor(i / CHANNEL_COUNT)] : alpha[i % CHANNEL_COUNT]))\n  );\n\nexport const splitRgbAndAlpha = (data: Uint8Array) => {\n  const rgbBytes = data.filter(isRgbByte);\n  const alphaBytes = data.filter(isAlphaByte);\n  return [rgbBytes, alphaBytes];\n};\n","import { createCipheriv, createDecipheriv, createHash, scryptSync } from 'crypto';\n\nimport { ENCRYPTION_METHOD } from './defaults';\n\nexport const decryptBuffer = (data: Buffer, password: string) => {\n  const iv = scryptSync(password, password.slice(4), 16);\n  const key = scryptSync(password, password.slice(-4), 32);\n  const decipher = createDecipheriv(ENCRYPTION_METHOD, key, iv);\n  const chunk1 = decipher.update(data);\n  const chunk2 = decipher.final();\n  return Buffer.concat([chunk1, chunk2], chunk1.length + chunk2.length);\n};\n\nexport const encryptBuffer = (message: Buffer, password: string) => {\n  const iv = scryptSync(password, password.slice(4), 16);\n  const key = scryptSync(password, password.slice(-4), 32);\n  const cipher = createCipheriv(ENCRYPTION_METHOD, key, iv);\n  const chunk1 = cipher.update(message);\n  const chunk2 = cipher.final();\n  return Buffer.concat([chunk1, chunk2], chunk1.length + chunk2.length);\n};\n\nexport const getShasumData = (message: Buffer) => createHash('sha256').update(message).digest();\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,mBAAoB;;;ACDb,IAAM,YAAY;AAClB,IAAM,oBAAoB;AAC1B,IAAM,eAAe;AACrB,IAAM,eAAe;;;ACA5B,IAAM,gBAAgB,CAAC,KAAK,KAAK,KAAK,GAAG,EAAE;AAKpC,IAAM,YAAY,CAAC,GAAW,OAAe,IAAI,KAAK;;;ACR7D,oBAAyE;AAIlE,IAAM,gBAAgB,CAAC,MAAc,aAAqB;AAC/D,QAAM,SAAK,0BAAW,UAAU,SAAS,MAAM,CAAC,GAAG,EAAE;AACrD,QAAM,UAAM,0BAAW,UAAU,SAAS,MAAM,EAAE,GAAG,EAAE;AACvD,QAAM,eAAW,gCAAiB,mBAAmB,KAAK,EAAE;AAC5D,QAAM,SAAS,SAAS,OAAO,IAAI;AACnC,QAAM,SAAS,SAAS,MAAM;AAC9B,SAAO,OAAO,OAAO,CAAC,QAAQ,MAAM,GAAG,OAAO,SAAS,OAAO,MAAM;AACtE;AAWO,IAAM,gBAAgB,CAAC,gBAAoB,0BAAW,QAAQ,EAAE,OAAO,OAAO,EAAE,OAAO;;;AHb9F,IAAM,gBAAgB,CAAC,MAAc,IAAI;AAEzC,IAAM,mBAAmB,CAAC,gBAAwB,CAAC,GAAW,MAAc;AAC1E,QAAM,QAAQ,IAAI;AAClB,SAAO,YAAY,MAAM,OAAO,QAAQ,SAAS;AACnD;AAEA,IAAM,qBAAqB,CAAC,aAAqB,aAAqB,MAAc;AAClF,QAAM,gBAAgB,YAAY,IAAI;AAEtC,SAAQ,eAAe,gBAAiB;AAE1C;AAEA,IAAM,wBAAwB,CAAC,WAAmB,OAAO,OAAO,oBAAoB,CAAC;AAErF,IAAM,cAAc,CAAC,gBAAwB;AAC3C,QAAM,IAAI,KAAK,KAAK,YAAY,SAAS,SAAS;AAClD,SAAO,MAAM,CAAC,EAAE,KAAK,IAAI,EAAE,IAAI,iBAAiB,WAAW,CAAC,EAAE,IAAI,qBAAqB;AACzF;AAEA,IAAM,SAAS,CAAC,SAAyB;AACvC,QAAM,cAAc,KAAK,IAAI,aAAa;AAC1C,QAAM,WAAW,YAAY,WAAW;AACxC,SAAO,OAAO,KAAK,QAAQ;AAC7B;AAEA,IAAM,uBAAuB,CAAC,SAAiB,WAA4B,cAAc,OAAO,EAAE,OAAO,MAAM;AAE/G,IAAM,cAAc,CAAC,cAAsB;AACzC,QAAM,MAAkB,UAAU,OAAO,SAAS;AAElD,QAAM,iBAAiB,eAAe;AACtC,QAAM,iBAAiB,eAAe;AACtC,QAAM,sBAAsB,iBAAiB;AAE7C,QAAM,aAAa,IAAI,MAAM,GAAG,cAAc;AAC9C,QAAM,oBAAoB,OAAO,UAAU;AAC3C,QAAM,SAAS,SAAS,kBAAkB,SAAS,KAAK,GAAG,EAAE,IAAI;AAEjE,QAAM,aAAa,IAAI,MAAM,gBAAgB,mBAAmB;AAChE,QAAM,oBAAoB,OAAO,UAAU;AAE3C,QAAM,cAAc,IAAI,MAAM,qBAAqB,sBAAsB,MAAM;AAC/E,QAAM,qBAAqB,OAAO,WAAW;AAE7C,MAAI,CAAC,qBAAqB,oBAAoB,iBAAiB;AAC7D,UAAM,IAAI,MAAM,sCAAsC;AAExD,SAAO;AACT;AAEO,IAAM,eAAe,CAAC,OAAe,UAA2B,aAAsB;AAC3F,QAAM,MAAW,iBAAI,KAAK,KAAK,KAAK;AACpC,QAAM,OAAO,YAAY,IAAI,IAAI;AACjC,QAAM,SAAS,WAAW,cAAc,MAAM,QAAQ,IAAI;AAC1D,SAAO,WAAW,OAAO,SAAS,QAAQ,IAAI;AAChD;","names":[]}