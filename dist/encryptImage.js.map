{"version":3,"sources":["../src/encryptImage.ts","../src/defaults.ts","../src/png.ts","../src/utils.ts"],"sourcesContent":["import { PNG } from 'pngjs';\n\nimport { BYTE_SIZE, LENGTH_BYTES, SHASUM_BYTES } from './defaults';\nimport { countBytesForNRgbBytes, recombineRgbAndAlpha, splitRgbAndAlpha } from './png';\nimport { encryptBuffer, getShasumData } from './utils';\n\nconst getLengthData = (message: Buffer) => {\n  const lengthHex = message.length.toString(16);\n  const lengthBuffer = Buffer.from(lengthHex.length % 2 ? `0${lengthHex}` : lengthHex, 'hex');\n  const pad = Buffer.alloc(LENGTH_BYTES - lengthBuffer.length);\n  return Buffer.concat([pad, lengthBuffer], LENGTH_BYTES);\n};\n\nconst getBit = (data: Buffer) => (i: number) => {\n  const byteIndex = Math.floor(i / BYTE_SIZE);\n  const bitIndex = i % BYTE_SIZE;\n\n  const byte = data[byteIndex];\n  const shiftDistance = BYTE_SIZE - 1 - bitIndex;\n  /* tslint:disable:no-bitwise */\n  return (byte >> shiftDistance) % 2;\n  /* tslint:enable:no-bitwise */\n};\n\n/* tslint:disable:no-bitwise */\nconst addDataToByte = (data: Buffer) => (byte: number, i: number) => ((byte >> 1) << 1) | getBit(data)(i);\n/* tslint:enable:no-bitwise */\n\nconst embedData = ([data, bed]: any[]) => bed.map(addDataToByte(data));\n\nconst store = (imageData: Buffer, message: Buffer) => {\n  const bytesAvailable = imageData.length;\n  const bytesToStore = LENGTH_BYTES + SHASUM_BYTES + message.length;\n  const bytesRequired = countBytesForNRgbBytes(bytesToStore);\n\n  if (bytesAvailable < bytesRequired) throw new Error('Image is not large enough to store message');\n\n  const lengthData = getLengthData(message);\n  const shasumData = getShasumData(message);\n\n  const bytesToUse = imageData.slice(0, bytesRequired);\n  const bytesToLeave = imageData.slice(bytesRequired);\n\n  const [rgb, alpha] = splitRgbAndAlpha(bytesToUse);\n\n  const lengthDataSize = LENGTH_BYTES * BYTE_SIZE;\n  const shasumDataSize = SHASUM_BYTES * BYTE_SIZE;\n\n  const bytesToUseWithLengthData = rgb.slice(0, lengthDataSize);\n  const bytesToUseWithShasumData = rgb.slice(lengthDataSize, lengthDataSize + shasumDataSize);\n  const bytesToUseWithMessageData = rgb.slice(lengthDataSize + shasumDataSize);\n\n  const embeddedData = Buffer.concat(\n    [\n      [lengthData, bytesToUseWithLengthData],\n      [shasumData, bytesToUseWithShasumData],\n      [message, bytesToUseWithMessageData],\n    ].map(embedData),\n    rgb.length\n  );\n\n  const recombined = recombineRgbAndAlpha(embeddedData, alpha);\n  const adjustedImageData = Buffer.concat([recombined, bytesToLeave], bytesAvailable);\n\n  return adjustedImageData;\n};\n\nexport const encryptImage = (image: Buffer, message: string | Buffer, encoding?: BufferEncoding, password?: string) => {\n  const messageBuffer: Buffer = Buffer.isBuffer(message) ? message : Buffer.from(message, encoding);\n  const secretBuffer: Buffer = password ? encryptBuffer(messageBuffer, password) : messageBuffer;\n\n  const png: PNG = PNG.sync.read(image);\n  const data = store(png.data, secretBuffer);\n  const adjustedPng: PNG = Object.assign({}, png, { data });\n\n  return PNG.sync.write(adjustedPng);\n};\n","export const BYTE_SIZE = 8;\nexport const ENCRYPTION_METHOD = 'aes256';\nexport const LENGTH_BYTES = 8;\nexport const SHASUM_BYTES = 32;\n","// const { BYTE_SIZE } = require('./defaults')\nimport { BYTE_SIZE } from './defaults';\n\nconst CHANNEL_COUNT = ['r', 'g', 'b', 'a'].length;\n\nexport const countBytesForNRgbBytes = (n: number) => Math.floor((n * BYTE_SIZE * CHANNEL_COUNT) / (CHANNEL_COUNT - 1));\n\nexport const isAlphaByte = (_: number, i: number) => !((i + 1) % CHANNEL_COUNT);\nexport const isRgbByte = (_: number, i: number) => (i + 1) % CHANNEL_COUNT;\n\nexport const recombineRgbAndAlpha = (rgb: Buffer, alpha: Uint8Array) =>\n  Buffer.from(\n    Array(rgb.length + alpha.length)\n      .fill(null)\n      .map((_, i) => ((i + 1) % CHANNEL_COUNT ? rgb[i - Math.floor(i / CHANNEL_COUNT)] : alpha[i % CHANNEL_COUNT]))\n  );\n\nexport const splitRgbAndAlpha = (data: Uint8Array) => {\n  const rgbBytes = data.filter(isRgbByte);\n  const alphaBytes = data.filter(isAlphaByte);\n  return [rgbBytes, alphaBytes];\n};\n","import { createCipheriv, createDecipheriv, createHash, scryptSync } from 'crypto';\n\nimport { ENCRYPTION_METHOD } from './defaults';\n\nexport const decryptBuffer = (data: Buffer, password: string) => {\n  const iv = scryptSync(password, password.slice(4), 16);\n  const key = scryptSync(password, password.slice(-4), 32);\n  const decipher = createDecipheriv(ENCRYPTION_METHOD, key, iv);\n  const chunk1 = decipher.update(data);\n  const chunk2 = decipher.final();\n  return Buffer.concat([chunk1, chunk2], chunk1.length + chunk2.length);\n};\n\nexport const encryptBuffer = (message: Buffer, password: string) => {\n  const iv = scryptSync(password, password.slice(4), 16);\n  const key = scryptSync(password, password.slice(-4), 32);\n  const cipher = createCipheriv(ENCRYPTION_METHOD, key, iv);\n  const chunk1 = cipher.update(message);\n  const chunk2 = cipher.final();\n  return Buffer.concat([chunk1, chunk2], chunk1.length + chunk2.length);\n};\n\nexport const getShasumData = (message: Buffer) => createHash('sha256').update(message).digest();\n"],"mappings":"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","names":[]}